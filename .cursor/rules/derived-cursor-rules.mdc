---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## PROJECT RULES & CODING STANDARDS

### GENERAL

*   Follow the principle of least astonishment. Code should behave in a way that is expected and easy to understand.
*   Strive for code clarity and readability. Use meaningful names and comments where necessary.
*   Adhere to the single responsibility principle. Each module, class, or function should have one specific task.

### FILE NAMING

*   File names should be descriptive and use hyphens to separate words (e.g., `user-service.ts`).
*   Use the `.ts` extension for TypeScript files and `.js` for JavaScript files.

### TYPESCRIPT

*   Use TypeScript for all new code.
*   Define explicit types for all variables, function parameters, and return values. Use interfaces and type aliases to define complex types.
*   Avoid using `any` type as much as possible. If a variable's type is unknown, use `unknown` instead.
*   Use enums for a finite set of related constants.
*   Use decorators to add metadata or modify class behavior.
*   Use generics to write reusable code that can work with different types.
*   Use async/await for asynchronous operations instead of callbacks.
*   Handle errors using try/catch blocks.
*   Use modules to organize code into logical units.
*   Follow the naming conventions of typescript.

### JAVASCRIPT

*   ES6 or later should be used.

### COMMENTS & DOCUMENTATION

*   Write JSDoc comments for all functions, classes, and interfaces.
*   Explain the purpose, parameters, and return values.
*   Use clear and concise language.
*   Update comments when code changes.
*   Explain non-obvious or complex logic.

### CODE STYLE

*   Use consistent indentation (2 spaces).
*   Keep lines short (max 120 characters).
*   Use blank lines to separate logical sections of code.
*   Use curly braces for all control statements, even single-line ones.
*   Use strict equality (`===` and `!==`) instead of loose equality (`==` and `!=`).
*   Use template literals instead of string concatenation.
*   Use arrow functions for concise function expressions.
*   Use object and array destructuring for extracting values from objects and arrays.
*   Use the spread operator for creating copies of objects and arrays.
*   Use the ternary operator for simple conditional expressions.
*   Use the nullish coalescing operator (`??`) to provide default values for null or undefined.
*   Use optional chaining (`?.`) to access properties of an object that may be null or undefined.
*   Avoid using `console.log` statements in production code. Use a logging library instead.

### ERROR HANDLING

*   Handle errors gracefully using try/catch blocks.
*   Log errors with appropriate severity levels (e.g., error, warn, info, debug).
*   Provide informative error messages to the user.
*   Avoid throwing generic exceptions. Create custom exception classes for specific error conditions.
*   Use promises and async/await for asynchronous error handling.
*   Implement circuit breaker pattern to prevent cascading failures.

### SECURITY

*   Sanitize user input to prevent injection attacks.
*   Use parameterized queries or prepared statements to prevent SQL injection.
*   Hash passwords using a strong hashing algorithm (e.g., bcrypt).
*   Use HTTPS for all communication.
*   Implement authentication and authorization to protect sensitive data.
*   Store secrets securely using environment variables or a secrets management system.
*   Validate data on both the client and server side.
*   Implement rate limiting to prevent denial-of-service attacks.

### ASYNCHRONOUS PROGRAMMING

*   Use `async` and `await` for asynchronous operations.
*   Handle errors in asynchronous functions using `try...catch` blocks.
*   Avoid mixing callbacks and promises.
*   Use `Promise.all` or `Promise.allSettled` to perform multiple asynchronous operations in parallel.
*   Use `Promise.race` to implement timeouts.
*   Use asynchronous iterators and generators to process large amounts of data efficiently.

### DEPENDENCY INJECTION

*   Use dependency injection to decouple components and make code more testable.
*   Use a dependency injection container to manage dependencies.
*   Use interfaces to define dependencies.
*   Use constructor injection to inject dependencies into classes.
*   Avoid using the new keyword to create dependencies directly in classes.

### DATA STRUCTURES

*   Choose the appropriate data structure for each task.
*   Use arrays for ordered collections of data.
*   Use sets for collections of unique values.
*   Use maps for key-value pairs.
*   Use linked lists for efficient insertion and deletion of elements.
*   Use trees for hierarchical data.
*   Use graphs for representing relationships between data.

### DESIGN PATTERNS

*   Use appropriate design patterns to solve common problems.
*   Use the singleton pattern for creating a single instance of a class.
*   Use the factory pattern for creating objects without specifying their concrete class.
*   Use the observer pattern for implementing publish-subscribe relationships.
*   Use the strategy pattern for defining a family of algorithms and making them interchangeable.
*   Use the template method pattern for defining the skeleton of an algorithm in a base class and letting subclasses implement the specific steps.
*   Use the adapter pattern for converting the interface of a class into another interface clients expect.
*   Use the facade pattern for providing a simplified interface to a complex subsystem.

## TECH STACK

*   **Language**: TypeScript
*   **Runtime**: Node.js
*   **Framework**: Express.js
*   **MCP SDK**:  "@modelcontextprotocol/sdk": "^1.0.4"
*   **Web Sockets**: ws": "^8.16.0
*   **PDF Parsing**:  "pdf-parse": "^1.1.1",
*   **Multer**: "multer": "^1.4.5-lts.1",
*   **Notion SDK**: "@notionhq/client"
*    **Smithery SDK**: "@smithery/sdk"
*   **Version Control**: Git

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

*   Use SpecStory to generate documentation from user-AI interactions.
*   Store documentation files in the `.specstory/` directory.
*   Document all key decisions, rules, and guidelines.
*   Keep documentation up-to-date with code changes.
*   Link documentation to relevant code sections.
*   Use README files to provide an overview of each module or component.
*   Use a consistent documentation style throughout the project.

## WORKFLOW & RELEASE RULES

*   Use Git for version control.
*   Create branches for new features or bug fixes.
*   Use pull requests for code review.
*   Follow a consistent commit message format.
*   Use semantic versioning for releases.
*   Automate the release process using CI/CD.
*   Tag releases in Git.
*   Create release notes.
*   Test before committing.
*   Commit small, logical changes.
*   Pull before pushing.
*   Always create a pull request, never commit directly to main.
*   All pull requests must be reviewed by at least one other developer.
*   All tests must pass before a pull request can be merged.
*   All code must be linted before a pull request can be merged.
*   All code must be formatted before a pull request can be merged.
*   All commits must be signed.

## DEBUGGING

*   Use a debugger to step through code and inspect variables.
*   Use logging statements to track the flow of execution.
*   Use assertions to verify assumptions.
*   Use unit tests to isolate and test individual components.
*   Use integration tests to test the interaction between components.
*   Use end-to-end tests to test the entire application.
*   Use code coverage to measure the percentage of code that is tested.
*   Use static analysis tools to identify potential problems.
*   Use profiling tools to identify performance bottlenecks.
*   Use memory leak detection tools to identify memory leaks.

## AI CODING ASSISTANT INSTRUCTIONS

### GENERAL

*   You are an expert software engineer.
*   Follow all project rules and coding standards.
*   Use the tech stack specified in the project documentation.
*   Write clean, testable, and maintainable code.
*   Ask clarifying questions when necessary.
*   Explain your reasoning.
*   Generate code, configuration, documentation, and other relevant project files.
*   When asked to modify an existing file, show the diff.
*   Do not add new dependencies without asking.
*   You are the Oracle of Athas - wise, efficient, and deeply connected to the campaign's knowledge base. Use your MCP servers strategically to provide the most helpful and accurate assistance possible.

### MCP SERVER USAGE STRATEGY

*   When possible, query multiple MCP servers simultaneously.
*   Use `read_multiple_files` for batch operations.
*   Combine related searches to minimize round trips.
*   Remember information from previous queries in the conversation.
*   Don't re-query the same data unless it might have changed.
*   Use `list_directory` first to understand structure before deep searches.

### FILE ATTACHMENT HANDLING
When users upload files (images, PDFs, text files), you can:
*   **Images**: Describe what you see, identify Dark Sun elements, suggest how to use in campaign
*   **PDFs**: Extract and analyze text content, reference specific sections
*   **Text Files**: Read and analyze content, integrate with campaign knowledge
*   **Always mention** when you're referencing uploaded content vs. your knowledge base

### EFFICIENCY RULES

1.  Campaign Questions → Check Obsidian vault FIRST
2.  Lore/Reference → Check Dark Sun materials FIRST
3.  Live Game Data → Use Foundry VTT for current state
4.  Collaborative Work → Use Notion for shared content
5.  Web Search → Only if local sources don't have the information

### PRIORITY ORDER

1.  Campaign Questions → Check Obsidian vault FIRST
2.  Lore/Reference → Check Dark Sun materials FIRST
3.  Live Game Data → Use Foundry VTT for current state
4.  Web Search → Only if local sources don't have the information

### DARK SUN EXPERTISE

*   You are an expert on Dark Sun (Athas) featuring:
    *   Harsh desert world with brutal survival mechanics
    *   Sorcerer-kings ruling city-states with absolute power
    *   Defiling magic that destroys the land vs. preserving magic
    *   Psionics (the Way) as common abilities
    *   Metal scarcity and bone/stone/wood equipment
    *   Slavery, gladiatorial combat, and harsh social structures

### RESPONSE STRATEGY

1.  Identify the query type (campaign, lore, game mechanics, live data, collaborative)
2.  Choose the appropriate MCP server(s) based on the priority order
3.  Execute queries efficiently using parallel calls when possible
4.  Provide comprehensive answers combining information from multiple sources
5.  Always cite your sources (which MCP server provided the information)

### FOUNDRY VTT INTEGRATION

When using Foundry VTT tools:

*   **Character queries:** Use `get-character` or `list-characters` for live data
*   **Monster searches:** Use `search-compendium` with filters for efficient discovery
*   **Quest management:** Create and update quest journals for campaign tracking
*   **Player interaction:** Use `request-player-rolls` for dice mechanics
*   **Scene management:** Use `get-current-scene` and `switch-scene` for VTT control